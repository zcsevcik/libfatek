/*
 * zcsevcik/libfatek/detail/address/basic_parser.hpp
 *
 * Author(s):      Radek Sevcik <zcsevcik@gmail.com>
 * Date:           2017/06/20
 *
 * This file is part of zcsevcik/libfatek.
 */

#ifndef ZCSEVCIK_LIBFATEK_DETAIL_ADDRESS_BASIC_PARSER_HPP_
#define ZCSEVCIK_LIBFATEK_DETAIL_ADDRESS_BASIC_PARSER_HPP_

#include "address.hpp"
#include <cerrno>
#include <cstdlib>
#include <locale>

namespace zcsevcik {
namespace libfatek {
namespace detail {
/* ======================================================================= */
class basic_parser final
{
    const char* input;

public:
    explicit basic_parser(const char* s) noexcept
      : input(s)
    {
    }

public:
    address::symbol_t operator()(uint16_t* address = nullptr) const noexcept
    {
        address::symbol_t sym = symbol(input);
        if (sym == address::invalid_symbol)
            return address::invalid_symbol;

        if (address != nullptr)
        {
            const char* strNum = &input[find_first_not_upper_ascii(input)];
            int iAddress = u16(strNum);

            if (iAddress == -1)
                return address::invalid_symbol;
            *address = static_cast<uint16_t>(iAddress);
        }

        return sym;
    }

private:
    static address::symbol_t symbol(const char*) noexcept;
    static int u16(const char*) noexcept;
    static std::size_t find_first_not_upper_ascii(const char* s);
};

/* ======================================================================= */
address::symbol_t
basic_parser::symbol(const char* YYCURSOR) noexcept
{
  /*!re2c
    re2c:define:YYCTYPE = char;
    re2c:yyfill:enable = 0;

    dec = [0-9]+;
    end = "\x00";

    "*"           { return static_cast<address::symbol_t>(-1); }
    "C"   dec end { return address::C; }
    "WC"  dec end { return address::WC; }
    "DWC" dec end { return address::DWC; }
    "RC"  dec end { return address::RC; }
    "DRC" dec end { return address::DRC; }
    "D"   dec end { return address::D; }
    "DD"  dec end { return address::DD; }
    "R"   dec end { return address::R; }
    "DR"  dec end { return address::DR; }
    "F"   dec end { return address::F; }
    "DF"  dec end { return address::DF; }
    "X"   dec end { return address::X; }
    "WX"  dec end { return address::WX; }
    "DWX" dec end { return address::DWX; }
    "M"   dec end { return address::M; }
    "WM"  dec end { return address::WM; }
    "DWM" dec end { return address::DWM; }
    "Y"   dec end { return address::Y; }
    "WY"  dec end { return address::WY; }
    "DWY" dec end { return address::DWY; }
    "S"   dec end { return address::S; }
    "WS"  dec end { return address::WS; }
    "DWS" dec end { return address::DWS; }
    "T"   dec end { return address::T; }
    "WT"  dec end { return address::WT; }
    "DWT" dec end { return address::DWT; }
    "RT"  dec end { return address::RT; }
    "DRT" dec end { return address::DRT; }
  */
}

/* ======================================================================= */
int
basic_parser::u16(const char* s) noexcept
{
    errno = 0;
    char *s_end = nullptr;
    long value = std::strtol(s, &s_end, 10);

    if (s_end == s || *s_end != '\0')
        return -1;
    if (errno == ERANGE)
        return -1;
    if (not (0 <= value && value <= __UINT16_MAX__))
        return -1;

    return static_cast<int>(value);
}

/* ======================================================================= */
std::size_t
basic_parser::find_first_not_upper_ascii(const char* s)
{
    const char* s_end = s;
    while (std::isupper(*s_end, std::locale::classic()))
        ++s_end;

    return static_cast<std::size_t>(s_end-s);
};

/* ======================================================================= */

} /* namespace detail */
} /* namespace zcsevcik */
} /* namespace libfatek */

#endif /* ZCSEVCIK_LIBFATEK_DETAIL_ADDRESS_BASIC_PARSER_HPP_ */
